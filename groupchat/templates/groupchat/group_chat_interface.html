{% extends 'base.html' %}
{% load static %}
{% load groupchat_extras %} {# Load custom templatetags #}

{% block title %}{{ group.name }} - Chat | {{ platform_name|default:"BookHaven" }}{% endblock %}

{% block head_extra %}
    {# Add specific CSS for chat interface if needed later #}
    {# <link rel="stylesheet" href="{% static 'groupchat/css/chat_styles.css' %}"> #}
    <style>
        .chat-content-area { /* New wrapper for chat within the main content block */
            display: flex;
            flex-direction: column;
            height: 100%; /* Let it take full height of its parent flex-grow container */
            max-width: 900px; 
            margin: 0 auto; /* Center it if max-width is used */
            background-color: #fff; /* White background for the chat area itself */
            border: 1px solid #e5e7eb; /* Border around the chat area */
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            overflow: hidden; /* Prevent content from spilling if height calculations are tricky */
        }
        .chat-internal-header {
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e5e7eb; 
            flex-shrink: 0; 
            background-color: #f9fafb; /* Light gray for this header section */
        }
        .chat-internal-header h2 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* semibold */
            color: #4f46e5; /* indigo-600 */
        }
        .chat-internal-header p {
            font-size: 0.875rem; /* text-sm */
            color: #6b7280; /* gray-500 */
        }
        .message-list-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: #f9fafb; 
        }
        .message-bubble {
            max-width: 75%;
            width: fit-content; 
            padding: 10px 15px;
            border-radius: 18px; 
            margin-bottom: 10px;
            word-wrap: break-word;
        }
        .message-bubble.user-message {
            background-color: #4f46e5; 
            color: white;
            margin-left: auto; /* User messages to the right */
        }
        .message-bubble.other-message {
            background-color: #e5e7eb; 
            color: #1f2937; 
            margin-right: auto; /* Other messages to the left */
        }
        .message-meta {
            font-size: 0.75rem; 
            color: #6b7280; 
            margin-top: 4px;
            display: flex; /* For status icon alignment */
            align-items: center;
            gap: 5px; /* Space between timestamp and status */
        }
        .user-message .message-meta {
            color: #c7d2fe; 
            text-align: right;
        }
        .message-status {
            font-size: 0.7rem;
            font-weight: bold;
        }
        .status-sending { color: #fbbf24; } /* amber-400 */
        .status-sent { color: #22c55e; } /* green-500 */
        .status-failed { color: #ef4444; } /* red-500 */
        .message-form-wrapper {
            padding: 12px;
            background-color: #f3f4f6; /* Slightly different gray for input area */
            border-top: 1px solid #e5e7eb; 
            flex-shrink: 0; 
        }
        .form-field-container {
            display: flex;
            align-items: flex-end; 
            gap: 0.75rem; 
        }
        .form-field-container textarea {
            flex-grow: 1;
        }
        .file-input-label, button[type="submit"] {
            white-space: nowrap;
        }
        .file-input-label {
            padding: 0.65rem; /* Adjusted padding */
        }
        button[type="submit"] {
             padding: 0.65rem 1.25rem; /* Adjusted padding */
        }
        .file-name-feedback, .errorlist {
            margin-top: 5px;
            margin-left: 5px;
        }
    </style>
{% endblock %}

{% block content %} {# Chat interface now lives within the standard content block #}
<div class="chat-content-area">
    <div class="chat-internal-header">
        <h2>{{ group.name }}</h2>
        <p>Focus: {{ group.content_item.title }}</p>
    </div>

    <div class="message-list-wrapper">
        {# Messages will be dynamically populated by WebSocket #}
        {# Keep existing messages if any are rendered by the initial HTTP request (e.g., message history) #}
        {% if messages %}
            {% for message_item in messages %}
                <div class="message-bubble {% if message_item.user == request.user %}user-message{% else %}other-message{% endif %}" data-message-id="{{ message_item.id }}">
                    {% if message_item.user == request.user %}
                        <strong class="block text-sm mb-1">You</strong>
                    {% else %}
                        <strong class="block text-sm mb-1">{{ message_item.user.get_full_name|default:message_item.user.username }}</strong>
                    {% endif %}
                    {% if message_item.text_content %}<p>{{ message_item.text_content|linebreaksbr }}</p>{% endif %}
                    {% if message_item.file_attachment %}
                        <a href="{{ message_item.file_attachment.url }}" target="_blank" class="file-link mt-2 inline-block hover:underline">
                            <span class="file-name">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1 align-middle" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a3 3 0 006 0V7a1 1 0 112 0v4a5 5 0 01-10 0V7a3 3 0 013-3h1z" clip-rule="evenodd" /></svg>
                                {{ message_item.file_attachment.name|filename_only }}
                            </span>
                        </a>
                    {% endif %}
                    <div class="message-meta">
                        <span>{{ message_item.timestamp|date:"P, M d, Y" }}</span>
                        {% if message_item.user == request.user %}
                            {# Assuming messages loaded from history are considered "sent" #}
                            <span class="message-status status-sent" title="Sent">[S]</span> 
                        {% endif %}
                    </div>
                </div>
            {% endfor %}
        {% else %}
            <p class="initial-chat-message text-center text-gray-500 py-10">No messages yet. Start the conversation!</p>
        {% endif %}
    </div>

    <div class="message-form-wrapper">
        {# The form tag is still useful for structure, but its default submission will be prevented #}
        <form method="post" enctype="multipart/form-data" class="form-field-container" id="chat-message-form">
            {% csrf_token %}
            {{ form.text_content }} 
            <label for="{{ form.file_attachment.id_for_label }}" class="file-input-label">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>
            </label>
            {{ form.file_attachment }} 
            <button id="send-message-button" type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg transition">
                Send
            </button>
        </form>
        <p id="file-chosen-feedback" class="file-name-feedback"></p>
        {% if form.non_field_errors %}
             <ul class="errorlist">
            {% for error in form.non_field_errors %}
                <li>{{ error }}</li>
            {% endfor %}
            </ul>
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ block.super }}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const messageListWrapper = document.querySelector('.message-list-wrapper');
        const textInput = document.getElementById('{{ form.text_content.id_for_label }}');
        const fileInput = document.getElementById('{{ form.file_attachment.id_for_label }}');
        const fileChosenFeedback = document.getElementById('file-chosen-feedback');
        const sendButton = document.getElementById('send-message-button');
        const chatForm = document.getElementById('chat-message-form');
        const currentUserId = "{{ request.user.id|stringformat:'s' }}"; // Ensure it's a string for comparison
        const groupId = "{{ group.id }}";

        // Scroll to bottom of message list on initial load
        if (messageListWrapper) {
            messageListWrapper.scrollTop = messageListWrapper.scrollHeight;
        }
        if (textInput) {
            textInput.focus(); 
        }

        // WebSocket setup
        let chatSocketProtocol = window.location.protocol === "https" ? "wss" : "ws";
        // Workaround for dev tunnels that might not correctly set X-Forwarded-Proto for ASGI
        if (window.location.host === 'h35f8r9h-5000.inc1.devtunnels.ms') {
            chatSocketProtocol = 'wss';
        }

        const chatSocket = new WebSocket(
            chatSocketProtocol + '://' + window.location.host + '/ws/chat/' + groupId + '/'
        );

        chatSocket.onopen = function(e) {
            console.log('Chat socket successfully connected.');
        };

        chatSocket.onclose = function(e) {
            console.error('Chat socket closed unexpectedly. Code:', e.code, 'Reason:', e.reason);
            // Optionally, try to reconnect or inform the user
        };

        chatSocket.onerror = function(err) {
            console.error('WebSocket Error: ', err);
            // Inform the user that connection failed
            const errorDiv = document.createElement('div');
            errorDiv.className = 'text-red-500 text-center p-2';
            errorDiv.textContent = 'Error connecting to chat. Please refresh the page.';
            messageListWrapper.prepend(errorDiv);
        };

        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            const messageType = data.message_type || (data.type === 'message.error' ? 'message.error' : 'new_message'); // Infer type

            const initialMessagePlaceholder = messageListWrapper.querySelector('.initial-chat-message');
            if (initialMessagePlaceholder) { initialMessagePlaceholder.remove(); }

            if (messageType === 'message.error' && data.temp_id) {
                const failedMsgElement = messageListWrapper.querySelector(`[data-temp-id="${data.temp_id}"]`);
                if (failedMsgElement) {
                    updateMessageStatus(failedMsgElement, 'failed', data.error);
                }
            } else if (messageType === 'new_message') {
                if (data.temp_id && data.user_id.toString() === currentUserId) {
                    // This is a confirmation for a message sent by the current user
                    const pendingMsgElement = messageListWrapper.querySelector(`[data-temp-id="${data.temp_id}"]`);
                    if (pendingMsgElement) {
                        pendingMsgElement.dataset.messageId = data.id; // Update to permanent ID
                        updateMessageStatus(pendingMsgElement, 'sent');
                        // No need to remove data-temp-id, it won't hurt
                    } else {
                        // This case should ideally not happen if UI is consistent
                        appendMessageToChat(data, true, 'sent'); 
                    }
                } else if (data.user_id.toString() !== currentUserId) {
                    // This is a new message from another user
                    appendMessageToChat(data, false, 'received'); // 'received' status for others (no icon shown for them)
                }
                // If it's own message echo but temp_id was somehow lost or not used, it would be caught by user_id check
                // but wouldn't update a pending message. This logic assumes temp_id is primary for updates.
            }
        };

        function updateMessageStatus(messageElement, status, errorText = '') {
            let statusIndicator = messageElement.querySelector('.message-status');
            if (!statusIndicator) {
                const metaDiv = messageElement.querySelector('.message-meta span:first-child'); // Find timestamp span
                if (metaDiv) { 
                    statusIndicator = document.createElement('span');
                    statusIndicator.classList.add('message-status');
                    metaDiv.parentNode.appendChild(statusIndicator); // Append to message-meta
                }
            }
            if (statusIndicator) {
                statusIndicator.classList.remove('status-sending', 'status-sent', 'status-failed');
                statusIndicator.classList.add(`status-${status}`);
                if (status === 'sending') statusIndicator.textContent = '[P]';
                else if (status === 'sent') statusIndicator.textContent = '[S]';
                else if (status === 'failed') statusIndicator.textContent = `[F] ${errorText}`.trim();
                statusIndicator.title = status.charAt(0).toUpperCase() + status.slice(1) + (errorText ? `: ${errorText}`: '');
            }
        }

        function appendMessageToChat(data, isOwnMessage, status = 'sent') {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message-bubble');
            if (data.temp_id) messageDiv.dataset.tempId = data.temp_id;
            if (data.id) messageDiv.dataset.messageId = data.id; // Server ID

            messageDiv.classList.add(isOwnMessage ? 'user-message' : 'other-message');

            const strong = document.createElement('strong');
            strong.classList.add('block', 'text-sm', 'mb-1');
            strong.textContent = isOwnMessage ? 'You' : data.user_full_name;
            messageDiv.appendChild(strong);

            if (data.text) {
                const p = document.createElement('p');
                p.innerHTML = data.text.replace(/\n/g, '<br>');
                messageDiv.appendChild(p);
            }
            
            const metaDiv = document.createElement('div');
            metaDiv.classList.add('message-meta');
            const timestampSpan = document.createElement('span');
            const timestamp = new Date(data.timestamp);
            timestampSpan.textContent = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }) + ', ' + 
                                   timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            metaDiv.appendChild(timestampSpan);

            if (isOwnMessage) {
                const statusSpan = document.createElement('span');
                statusSpan.classList.add('message-status');
                metaDiv.appendChild(statusSpan);
                updateMessageStatus(messageDiv, status); // Will use the statusSpan just created
            }
            messageDiv.appendChild(metaDiv);
            messageListWrapper.appendChild(messageDiv);
            messageListWrapper.scrollTop = messageListWrapper.scrollHeight;
        }

        function sendMessage() {
            const messageText = textInput.value.trim();
            if (messageText) {
                const tempId = 'temp_' + Date.now();
                const clientMessageData = {
                    text: messageText,
                    user_id: currentUserId, // For immediate UI update
                    user_full_name: "You", // For immediate UI update
                    timestamp: new Date().toISOString(),
                    temp_id: tempId
                };
                appendMessageToChat(clientMessageData, true, 'sending');

                chatSocket.send(JSON.stringify({
                    'message': messageText,
                    'temp_id': tempId
                }));
                textInput.value = ''; 
                autoResizeTextarea(); 
                updateSendButtonState(); 
                textInput.focus(); 
            }
        }

        if (chatForm) { chatForm.addEventListener('submit', function(event) { event.preventDefault(); sendMessage(); }); }
        function updateSendButtonState() {
            const textValue = textInput ? textInput.value.trim() : '';
            const fileSelected = fileInput ? fileInput.files.length > 0 : false;
            if (sendButton) {
                sendButton.disabled = !(textValue || fileSelected);
            }
        }
        if (fileInput) {
            fileInput.addEventListener('change', function() {
                if (fileChosenFeedback) {
                    if (this.files.length > 0) {
                        fileChosenFeedback.textContent = `Selected: ${this.files[0].name}`;
                    } else {
                        fileChosenFeedback.textContent = '';
                    }
                }
                updateSendButtonState();
                // Note: File sending via WebSocket is not implemented in this pass.
                // If a file is selected, the send button might enable, but `sendMessage` currently only sends text.
            });
        }
        if (textInput) {
            textInput.addEventListener('input', updateSendButtonState);
            textInput.addEventListener('keydown', function(event) { 
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault(); 
                    if (!sendButton.disabled) { sendMessage(); } // Ensure button is not disabled
                } 
            });
            function autoResizeTextarea() {
                textInput.style.height = 'auto';
                let newHeight = textInput.scrollHeight;
                textInput.style.height = newHeight + 'px';
            }
            textInput.addEventListener('input', autoResizeTextarea);
            if(textInput.value) autoResizeTextarea(); // Initial call if there's pre-filled text
            else textInput.style.height = 'auto'; // Ensure it starts small if empty
        }
        updateSendButtonState();
    });
</script>
{% endblock %} 